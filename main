{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 432,
   "id": "4ed519ff",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[nltk_data] Downloading package stopwords to\n",
      "[nltk_data]     C:\\Users\\User\\AppData\\Roaming\\nltk_data...\n",
      "[nltk_data]   Package stopwords is already up-to-date!\n"
     ]
    }
   ],
   "source": [
    "import re\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import os\n",
    "\n",
    "import gensim\n",
    "import nltk\n",
    "from nltk.tokenize.toktok import ToktokTokenizer\n",
    "\n",
    "from nltk.corpus import stopwords\n",
    "\n",
    "SEED = 42\n",
    "\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "\n",
    "torch.manual_seed(SEED)\n",
    "torch.backends.cudnn.deterministic = True\n",
    "\n",
    "nltk.download('stopwords')\n",
    "import math\n",
    "from torch.autograd import Variable\n",
    "from string import punctuation\n",
    "from torch import optim\n",
    "from torch.utils.data import TensorDataset, DataLoader\n",
    "from matplotlib import pyplot as plt\n",
    "from collections import Counter\n",
    "\n",
    "from sklearn import metrics\n",
    "from sklearn.model_selection import train_test_split\n",
    "import gensim.downloader\n",
    "\n",
    "\n",
    "\n",
    "#from bs4 import BeautifulSoup"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 433,
   "id": "a1891bd2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(37500, 4)\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>user_id</th>\n",
       "      <th>rating</th>\n",
       "      <th>label</th>\n",
       "      <th>review</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0</td>\n",
       "      <td>9.0</td>\n",
       "      <td>positive</td>\n",
       "      <td>Bromwell High is a cartoon comedy. It ran at t...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>10000</td>\n",
       "      <td>8.0</td>\n",
       "      <td>positive</td>\n",
       "      <td>Homelessness (or Houselessness as George Carli...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>10001</td>\n",
       "      <td>10.0</td>\n",
       "      <td>positive</td>\n",
       "      <td>Brilliant over-acting by Lesley Ann Warren. Be...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>10002</td>\n",
       "      <td>7.0</td>\n",
       "      <td>positive</td>\n",
       "      <td>This is easily the most underrated film inn th...</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>10003</td>\n",
       "      <td>8.0</td>\n",
       "      <td>positive</td>\n",
       "      <td>This is not the typical Mel Brooks film. It wa...</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "  user_id  rating     label                                             review\n",
       "0       0     9.0  positive  Bromwell High is a cartoon comedy. It ran at t...\n",
       "1   10000     8.0  positive  Homelessness (or Houselessness as George Carli...\n",
       "2   10001    10.0  positive  Brilliant over-acting by Lesley Ann Warren. Be...\n",
       "3   10002     7.0  positive  This is easily the most underrated film inn th...\n",
       "4   10003     8.0  positive  This is not the typical Mel Brooks film. It wa..."
      ]
     },
     "execution_count": 433,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#importing the training data\n",
    "#imdb_data=pd.read_csv('All_rated_reviews.csv')\n",
    "imdb_data1 = pd.read_csv('rated_and_not_rated_reviews_1.csv')\n",
    "imdb_data2 = pd.read_csv('rated_and_not_rated_reviews_2.csv')\n",
    "imdb_data = pd.concat([imdb_data1, imdb_data2], ignore_index=True)\n",
    "imdb_data = imdb_data.loc[:, ~imdb_data.columns.str.match('Unnamed')]\n",
    "print(imdb_data.shape)\n",
    "imdb_data.head(5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 434,
   "id": "decf413e",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>rating</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>count</th>\n",
       "      <td>25000.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>mean</th>\n",
       "      <td>5.477720</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>std</th>\n",
       "      <td>3.466477</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>min</th>\n",
       "      <td>1.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>25%</th>\n",
       "      <td>2.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>50%</th>\n",
       "      <td>5.500000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>75%</th>\n",
       "      <td>9.000000</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>max</th>\n",
       "      <td>10.000000</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "             rating\n",
       "count  25000.000000\n",
       "mean       5.477720\n",
       "std        3.466477\n",
       "min        1.000000\n",
       "25%        2.000000\n",
       "50%        5.500000\n",
       "75%        9.000000\n",
       "max       10.000000"
      ]
     },
     "execution_count": 434,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Summary of the dataset\n",
    "imdb_data.describe()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 435,
   "id": "643ae88c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "positive    18750\n",
       "negative    18750\n",
       "Name: label, dtype: int64"
      ]
     },
     "execution_count": 435,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#sentiment count to see that the model is balanced\n",
    "imdb_data['label'].value_counts()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 436,
   "id": "6a9663e4",
   "metadata": {},
   "outputs": [],
   "source": [
    "imdb_data['label'] = imdb_data['label'].apply(lambda x: 1 if x == 'positive' else 0 )\n",
    "labels = imdb_data['label']"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5b366b18",
   "metadata": {},
   "source": [
    "## Text Normalization"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 437,
   "id": "c4425d5f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Tokenization of text\n",
    "tokenizer = ToktokTokenizer()\n",
    "#Setting English stopwords\n",
    "stopword_list = nltk.corpus.stopwords.words('english')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "454f3179",
   "metadata": {},
   "source": [
    "#### Removing noise from text"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 438,
   "id": "01c4f9c5",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Bromwell High is a cartoon comedy. It ran at the same time as some other programs about school life, such as \"Teachers\". My 35 years in the teaching profession lead me to believe that Bromwell High\\'s satire is much closer to reality than is \"Teachers\". The scramble to survive financially, the insightful students who can see right through their pathetic teachers\\' pomp, the pettiness of the whole situation, all remind me of the schools I knew and their students. When I saw the episode in which a student repeatedly tried to burn down the school, I immediately recalled ......... at .......... High. A classic line: INSPECTOR: I\\'m here to sack one of your teachers. STUDENT: Welcome to Bromwell High. I expect that many adults of my age think that Bromwell High is far fetched. What a pity that it isn\\'t!'"
      ]
     },
     "execution_count": 438,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def remove_between_square_brackets(text):\n",
    "    # Removing the square brackets\n",
    "    return re.sub('\\[[^]]*\\]', '', text)\n",
    "\n",
    "\n",
    "def denoise_text(text):\n",
    "    # Removing noise from text\n",
    "    text = remove_between_square_brackets(text)\n",
    "    return text\n",
    "\n",
    "\n",
    "#Apply function on review column\n",
    "imdb_data['review']=imdb_data['review'].apply(denoise_text)\n",
    "imdb_data['review'][0]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1836eea9",
   "metadata": {},
   "source": [
    "#### Removing special characters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 439,
   "id": "af603ce6",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Bromwell High is a cartoon comedy It ran at the same time as some other programs about school life such as Teachers My  years in the teaching profession lead me to believe that Bromwell Highs satire is much closer to reality than is Teachers The scramble to survive financially the insightful students who can see right through their pathetic teachers pomp the pettiness of the whole situation all remind me of the schools I knew and their students When I saw the episode in which a student repeatedly tried to burn down the school I immediately recalled  at  High A classic line INSPECTOR Im here to sack one of your teachers STUDENT Welcome to Bromwell High I expect that many adults of my age think that Bromwell High is far fetched What a pity that it isnt'"
      ]
     },
     "execution_count": 439,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Define function for removing special characters\n",
    "def remove_special_characters(text, remove_digits=True):\n",
    "    pattern = r'[^a-zA-z0-9\\s]'  if not remove_digits else r'[^a-zA-Z\\s]'\n",
    "    text = re.sub(pattern,'',text)\n",
    "    return text\n",
    "\n",
    "# Apply function on review column\n",
    "imdb_data['review']=imdb_data['review'].apply(remove_special_characters)\n",
    "imdb_data['review'][0]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "86d7a415",
   "metadata": {},
   "source": [
    "#### Text Stemming"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 440,
   "id": "b2f1f751",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'bromwel high is a cartoon comedi it ran at the same time as some other program about school life such as teacher my year in the teach profess lead me to believ that bromwel high satir is much closer to realiti than is teacher the scrambl to surviv financi the insight student who can see right through their pathet teacher pomp the petti of the whole situat all remind me of the school i knew and their student when i saw the episod in which a student repeatedli tri to burn down the school i immedi recal at high a classic line inspector im here to sack one of your teacher student welcom to bromwel high i expect that mani adult of my age think that bromwel high is far fetch what a piti that it isnt'"
      ]
     },
     "execution_count": 440,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#Stemming the text (plays, playing, played -> play)\n",
    "def simple_stemmer(text):\n",
    "    ps=nltk.porter.PorterStemmer()\n",
    "    text= ' '.join([ps.stem(word) for word in text.split()])\n",
    "    return text\n",
    "\n",
    "#Apply function on review column\n",
    "imdb_data['review']=imdb_data['review'].apply(simple_stemmer)\n",
    "imdb_data['review'][0]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c1dd2881",
   "metadata": {},
   "source": [
    "#### Removing stopwords"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 441,
   "id": "d93ebd2b",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'bromwel high cartoon comedi ran time program school life teacher year teach profess lead believ bromwel high satir much closer realiti teacher scrambl surviv financi insight student see right pathet teacher pomp petti whole situat remind school knew student saw episod student repeatedli tri burn school immedi recal high classic line inspector im sack one teacher student welcom bromwel high expect mani adult age think bromwel high far fetch piti isnt'"
      ]
     },
     "execution_count": 441,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#set stopwords to english\n",
    "stop=set(stopwords.words('english'))\n",
    "\n",
    "\n",
    "#removing the stopwords\n",
    "def remove_stopwords(text, is_lower_case=False):\n",
    "    tokens = tokenizer.tokenize(text)\n",
    "    tokens = [token.strip() for token in tokens]\n",
    "    if is_lower_case:\n",
    "        filtered_tokens = [token for token in tokens if token not in stopword_list]\n",
    "    else:\n",
    "        filtered_tokens = [token for token in tokens if token.lower() not in stopword_list]\n",
    "    filtered_text = ' '.join(filtered_tokens)    \n",
    "    return filtered_text\n",
    "\n",
    "\n",
    "#Apply function on review column\n",
    "imdb_data['review']=imdb_data['review'].apply(remove_stopwords)\n",
    "imdb_data['review'][0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 442,
   "id": "453750f1",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['bromwel', 'high', 'cartoon', 'comedi', 'ran']"
      ]
     },
     "execution_count": 442,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def remove_punctuation(text):\n",
    "    \"\"\"\n",
    "    Removing punctuation from our reviews\n",
    "    Punctuations are !\"#$%&'()*+, -./:;<=>?@[\\]^_`{|}~\n",
    "    \"\"\"\n",
    "    #return map(lambda s: re.sub(r'[^\\s\\w]+', '', s).lower(), strings)\n",
    "    all_text = ''.join([word for word in text if word not in punctuation])\n",
    "\n",
    "    # split by new lines and spaces\n",
    "    reviews_split = all_text.split('\\n')\n",
    "    all_text = ' '.join(reviews_split)\n",
    "    # create a list of words\n",
    "    words = all_text.split()\n",
    "    return words\n",
    "\n",
    "\n",
    "imdb_data['review'] = imdb_data['review'].apply(lambda x: remove_punctuation(x))\n",
    "#first 5 words of the review are\n",
    "imdb_data['review'][0][:5]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bfdac35e",
   "metadata": {},
   "source": [
    "## Normalized reviews - are splitted into test train and validation sets"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5160dbaf",
   "metadata": {},
   "source": [
    "### Splitting the data set for training"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 443,
   "id": "3424e317",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Overall data set length is 37500\n",
      "From this index we see the negative reviews 18750\n"
     ]
    }
   ],
   "source": [
    "print(\"Overall data set length is\", imdb_data.shape[0]) \n",
    "print(\"From this index we see the negative reviews\", int(imdb_data.shape[0]/2))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b3d0f800",
   "metadata": {},
   "source": [
    "##### Calculation of indexes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 444,
   "id": "440b4598",
   "metadata": {},
   "outputs": [],
   "source": [
    "x = imdb_data['review']\n",
    "y = imdb_data['label']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 445,
   "id": "4dcfd80e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "X_train shape: (30000,)\n",
      "X_test shape: (3750,)\n",
      "y_train shape: (30000,)\n",
      "y_test shape: (3750,)\n",
      "X_val shape: (30000,)\n",
      "y val shape: (3750,)\n"
     ]
    }
   ],
   "source": [
    "# The training set size will be 80% of the data and both the test and validation sets will contain 10%\n",
    "\n",
    "x_train,x_test, y_train, y_test = train_test_split(x, y,\n",
    "    test_size=0.1, shuffle = True, random_state = 8)\n",
    "\n",
    "# Use the same function above for the validation set\n",
    "x_train, x_val, y_train, y_val = train_test_split(x_train, y_train, \n",
    "    test_size=1/9, random_state= 8) # 0.25 x 0.8 = 0.2\n",
    "\n",
    "print(\"X_train shape: {}\".format(x_train.shape))\n",
    "print(\"X_test shape: {}\".format(x_test.shape))\n",
    "print(\"y_train shape: {}\".format(y_train.shape))\n",
    "print(\"y_test shape: {}\".format(y_test.shape))\n",
    "print(\"X_val shape: {}\".format(y_train.shape))\n",
    "print(\"y val shape: {}\".format(y_test.shape))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c625c416",
   "metadata": {},
   "source": [
    "## Cutting off irregular reviews by lenght"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 446,
   "id": "d29f791a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Zero-length reviews: 0\n",
      "Maximum review length: 1494\n"
     ]
    }
   ],
   "source": [
    "# You do it more then once - put it to a variable: len_list = [len(x) for x ...]\n",
    "train_review_lens = Counter([len(x) for x in x_train])\n",
    "print(\"Zero-length reviews: {}\".format(train_review_lens[0]))\n",
    "print(\"Maximum review length: {}\".format(max(train_review_lens)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 447,
   "id": "c265e96a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x216 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "train_data_for_plot = [len(x) for x in x_train]\n",
    "# fixed bin size\n",
    "bins = np.arange(0, 100, 20) # fixed bin size\n",
    "plt.xlim([min(train_data_for_plot)-5, max(train_data_for_plot)/4+5])\n",
    "plt.hist(train_data_for_plot, bins=bins, alpha=0.8)\n",
    "plt.title('Train reviews lenght histogram')\n",
    "plt.xlabel('variable X (bin size = 5)')\n",
    "plt.ylabel('count')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 448,
   "id": "1d5467ac",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Zero-length reviews: 0\n",
      "Maximum review length: 788\n"
     ]
    }
   ],
   "source": [
    "test_review_lens = Counter([len(i) for i in x_test])\n",
    "print(\"Zero-length reviews: {}\".format(test_review_lens[0]))\n",
    "print(\"Maximum review length: {}\".format(max(test_review_lens)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 449,
   "id": "d1eb4f7a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 576x216 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "test_data_for_plot = [len(i) for i in x_test]\n",
    "# fixed bin size\n",
    "bins = np.arange(0, 100, 20) # fixed bin size\n",
    "plt.xlim([min(test_data_for_plot)-5, max(test_data_for_plot)/4+5])\n",
    "plt.hist(test_data_for_plot, bins=bins, alpha=0.8)\n",
    "plt.title('Train reviews lenght histogram')\n",
    "plt.xlabel('variable X (bin size = 5)')\n",
    "plt.ylabel('count')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 450,
   "id": "5355ccae",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Zero-length reviews: 0\n",
      "Maximum review length: 825\n"
     ]
    }
   ],
   "source": [
    "val_review_lens = Counter([len(i) for i in x_val])\n",
    "print(\"Zero-length reviews: {}\".format(val_review_lens[0]))\n",
    "print(\"Maximum review length: {}\".format(max(val_review_lens)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 451,
   "id": "b1eb6984",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAfQAAADgCAYAAAD15pSzAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjMuMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/Il7ecAAAACXBIWXMAAAsTAAALEwEAmpwYAAAcEklEQVR4nO3debglVXnv8e9PWkTmqSVMoTGiBr0JYF/TxiEO3AhEbGNAMQ6g5BIT4xCTKMZEuUlMNE4B8WowKKCoCE6tF6egqEQhaRBlVDoIaZChJTQzSsN7/6h1ZHM4p3uf7t69z6n+fp5nP6dq1fSuqr33e9aq2lWpKiRJ0tz2kHEHIEmS1p0JXZKkHjChS5LUAyZ0SZJ6wIQuSVIPmNAlSeoBE7o0IMmXkhw+C+L4YJK/HtO2z07yB7N9O0mOSfKx1Uy/JMnT13b90lwzb9wBSOsqye0Do5sDPwPubeN/WFWnDruuqjpwfca2tqrqleOOYZySLAB+DDy0qlatzTqq6nEbYjvSbGFC15xXVVtODCe5CviDqvrXyfMlmbehvrQ35LY0e/k+0IZkl7t6K8nTk1yT5I1Jrgc+kmS7JF9MsiLJzW14t4FlftENnOSIJOckeVeb98dJpm3BJ7mqbesHwB1J5iVZlOQ7SVYm+f5EF3CSFyZZOmn5P02ypA2flOTvBqY9J8mFbT3fSfJrrfzlSb4wMN8VSU4fGF+eZJ903pvkxiS3JrkoyeOH3I+vSHJZ2wdfSbLHwLRK8sq23ZVJ3p8kbdomSd6d5Kdt3/1Jm3+wIbFHkn9LcluSrybZsZV/q/1dmeT2JE+aJrxNk5zSlr8kycJJx2P/NvzEJEtb3W9I8p7ptpPkIUn+KsnVbX+dkmSbgfW+rE27KclfT9rOMUnOSPKxJLcCR7Rtf7ftn+uSHJ9k00n78I/bPrwtyd8m+ZV2nG9N8qnB+aVpVZUvX715AVcB+7fhpwOrgHcADwMeDuwA/B5d1/xWwOnA5waWP5uuhQ9wBHAP8L+BTYA/An4CZDXbvhDYvW1rV+Am4CC6f57/Vxuf37Z/G7DXwPL/ARzWhk8C/q4N7wvcCPxGi+Pwtq2HAY8EVrb17wJcDVzTlnskcHOb9mzgfGBbIMCvAjtPU4/BfbAYWNbmnwf8FfCdgXkL+GJb7y8DK4AD2rRXApcCuwHbAf/a5p83sJ3/BB7d9tfZwNvbtAWD804T5zHA3W3/bgL8A3DuNO+F7wIvbcNbAoum2w7wilbnR7Z5PwN8tE3bG7gdeAqwKfAuuvfI/gMx3QM8r+33hwNPABa1/bcAuAx43aR9+Hlga+BxdKeMzmrb36btw8PH/dnyNftfttDVd/cBb62qn1XVXVV1U1V9uqrurKrbgLcBv7Wa5a+uqg9V1b3AycDOwE6rmf+4qlpeVXcBLwHOrKozq+q+qvoasBQ4qKrupPsSfxFAkr2AxwJLpljnUcA/V9V5VXVvVZ1M96W/qKqupPvHYB/gacBXgJ8keWyr17er6j66JLNV20aq6rKqum5NO48uKf9Dm38V8PfAPoOtdLokvLKq/gv4RosF4AXAsVV1TVXdDLx9ivV/pKp+1PbXpwaWHdY5bf/eC3wU+PVp5rsHeFSSHavq9qo6dzXrfDHwnqq6sqpuB94EHNZ6Fg4BvlBV51TVz4G30CXkQd+tqs+1Y35XVZ1fVedW1aqqugr4Zx78nvvHqrq1qi4BLga+2rZ/C/Alun/qpNUyoavvVlTV3RMjSTZP8s+ty/RWui7XbZNsMs3y108MtCQMXattOssHhvcADm1drSuTrKRr2e3cpn+cltCB36frKbiTB9sD+LNJ69mdrkUO8E263ointeGz6RLGb7VxqurrwPHA+4Ebk5yQZOvV1GNw28cObPe/6Vr4uw7Mc/3A8J3cv392mbQ/BofXtOywJi+/2aQu/QlH0vUEXJ7kP5I8ZzXrnOjpmHA1Xet6JybVqR2vmyYt/4B6Jnl0ulM717f33N8DO05a5oaB4bumGJ/pftFGyISuvpvcevoz4DHAb1TV1nRJELoktb63t5yuq3bbgdcWVTXRUv0aMD/JPnSJ/ePTrHM58LZJ69m8qj7Rpk8k9Ke24W8yKaEDVNVxVfUEum7jRwN/MUR9ltP9UmBw2w+vqu8Msex1dN3tE3YfYplfhDuDede8sqorqupFwCPoTsGckWSLabbzE7p/ZCb8Mt2pmxuYVKckE6dxHrC5SeMfAC6nO72yNfCXrL/3m/QLJnRtbLaia/GsTLI98NYRbutjwMFJnt0uENss3YV6uwFU1T105/DfCWxPl+Cn8iHglUl+o13ctkWS30myVZv+TeAZwMOr6hrg28ABdInmewBJ/mdb/qHAHXTnnu8bog4fBN6U5HFtPdskOXTI+n8KeG2SXZNsC7xxyOWgOxd/H9155HWW5CVJ5rfTDytb8X3TbOcTwJ8m2TPJlnQt6tPaKYcz6I7pb7YL1Y5hzcl5K+BW4PZ2KuSP1kedpMlM6NrY/BPdhUo/Bc4FvjyqDVXVcrqLyv6SLnEsp2sVD37uPg7sD5xe0/y8qaqW0l2YdzzdRW7L6C7Ym5j+I7oLtb7dxm8FrgT+rZ1bhu6Cqw+15a+m6yZ+5xB1+Cxdi/aTrbv4YmDY3+p/CPgq8AO6fyzOpGvp3ru6hdp276S7vuHfWnf/oiG3OZ0DgEvS3bPgWLqLD++aZjsfpjsf/y2636jfDby6xXVJG/4kXWv9droLFn+2mm3/Od0pldvo9slp61gXaUqpWq89W5I0pXQ/+ftgVe2xxpnniNaCX0nXnf7jMYejjZwtdEkjkeThSQ5K93v8XelOb3x23HGtqyQHt4srt6D72dpFdD+Rk8bKhC5pVAL8H7pu/u/R/f76LWONaP1YTHfh3E+Avei67+3q1NjZ5S5JUg/YQpckqQdM6JIk9cCcftrajjvuWAsWLBh3GJIkbRDnn3/+T6tq/lTT5nRCX7BgAUuXLl3zjJIk9UCSq6ebZpe7JEk9YEKXJKkHTOiSJPWACV2SpB4woUuS1ANz+ip3bXwOft854w5haF949VPGHYKkjYgtdEmSemCkCT3Jnya5JMnFST6RZLMkeyY5L8myJKcl2bTN+7A2vqxNXzDK2CRJ6pORJfT2uMTXAAur6vHAJsBhwDuA91bVo+iewnRkW+RI4OZW/t42nyRJGsKou9znAQ9PMg/YHLgOeCZwRpt+MvC8Nry4jdOmPytJRhyfJEm9MLKEXlXXAu8C/osukd8CnA+srKpVbbZrgF3b8K7A8rbsqjb/DpPXm+SoJEuTLF2xYsWowpckaU4ZZZf7dnSt7j2BXYAtgAPWdb1VdUJVLayqhfPnT3l/ekmSNjqj7HLfH/hxVa2oqnuAzwBPBrZtXfAAuwHXtuFrgd0B2vRtgJtGGJ8kSb0xyoT+X8CiJJu3c+HPAi4FvgEc0uY5HPh8G17SxmnTv15VNcL4JEnqjVGeQz+P7uK2C4CL2rZOAN4IvD7JMrpz5Ce2RU4EdmjlrweOHlVskiT1zUjvFFdVbwXeOqn4SuCJU8x7N3DoKOORJKmvvFOcJEk9YEKXJKkHTOiSJPWACV2SpB4woUuS1AMmdEmSesCELklSD5jQJUnqARO6JEk9YEKXJKkHTOiSJPWACV2SpB4woUuS1AMmdEmSesCELklSD5jQJUnqARO6JEk9YEKXJKkHTOiSJPWACV2SpB4woUuS1AMmdEmSesCELklSD5jQJUnqARO6JEk9YEKXJKkHTOiSJPWACV2SpB4YaUJPsm2SM5JcnuSyJE9Ksn2SryW5ov3drs2bJMclWZbkB0n2G2VskiT1yahb6McCX66qxwK/DlwGHA2cVVV7AWe1cYADgb3a6yjgAyOOTZKk3hhZQk+yDfA04ESAqvp5Va0EFgMnt9lOBp7XhhcDp1TnXGDbJDuPKj5JkvpklC30PYEVwEeSfC/JvyTZAtipqq5r81wP7NSGdwWWDyx/TSuTJElrMMqEPg/YD/hAVe0L3MH93esAVFUBNZOVJjkqydIkS1esWLHegpUkaS4bZUK/Brimqs5r42fQJfgbJrrS298b2/Rrgd0Hlt+tlT1AVZ1QVQurauH8+fNHFrwkSXPJyBJ6VV0PLE/ymFb0LOBSYAlweCs7HPh8G14CvKxd7b4IuGWga16SJK3GvBGv/9XAqUk2Ba4EXk73T8SnkhwJXA28oM17JnAQsAy4s80rSZKGMNKEXlUXAgunmPSsKeYt4FWjjEeSpL7yTnGSJPWACV2SpB4woUuS1AMmdEmSesCELklSD5jQJUnqARO6JEk9YEKXJKkHTOiSJPWACV2SpB4woUuS1AMmdEmSesCELklSD5jQJUnqARO6JEk9MFRCT3LWMGWSJGk85q1uYpLNgM2BHZNsB6RN2hrYdcSxSZKkIa02oQN/CLwO2AU4n/sT+q3A8aMLS5IkzcRqE3pVHQscm+TVVfW+DRSTJEmaoTW10AGoqvcl+U1gweAyVXXKiOKSJEkzMFRCT/JR4FeAC4F7W3EBJnRJkmaBoRI6sBDYu6pqlMFIkqS1M+zv0C8GfmmUgUiSpLU3bAt9R+DSJP8O/GyisKqeO5KoJEnSjAyb0I8ZZRCSJGndDHuV+zdHHYgkSVp7w17lfhvdVe0AmwIPBe6oqq1HFZgkSRresC30rSaGkwRYDCwaVVCSJGlmZvy0tep8Dnj2+g9HkiStjWG73J8/MPoQut+l3z3kspsAS4Frq+o5SfYEPgnsQHd/+JdW1c+TPIzuRjVPAG4CXlhVVw1bEUmSNmbDttAPHng9G7iNrtt9GK8FLhsYfwfw3qp6FHAzcGQrPxK4uZW/t80nSZKGMOw59JevzcqT7Ab8DvA24PXt/Pszgd9vs5xM95O4D9D9g3BMKz8DOD5JvDudJElrNlQLPcluST6b5Mb2+nRL1mvyT8AbgPva+A7Ayqpa1cav4f7nqu8KLAdo029p80uSpDUYtsv9I8ASuuei7wJ8oZVNK8lzgBur6vx1ivDB6z0qydIkS1esWLE+Vy1J0pw1bEKfX1UfqapV7XUSMH8NyzwZeG6Sq+gugnsmcCywbZKJrv7dgGvb8LXA7gBt+jZ0F8c9QFWdUFULq2rh/PlrCkGSpI3DsAn9piQvSbJJe72EKZLtoKp6U1XtVlULgMOAr1fVi4FvAIe02Q4HPt+Gl7Rx2vSve/5ckqThDJvQXwG8ALgeuI4u4R6xltt8I90FcsvozpGf2MpPBHZo5a8Hjl7L9UuStNEZ9uEsfwMcXlU3AyTZHngXXaJfo6o6Gzi7DV8JPHGKee4GDh0yHkmSNGDYFvqvTSRzgKr6b2Df0YQkSZJmatiE/pAk202MtBb6sK17SZI0YsMm5XcD301yehs/lO5mMZIkaRYY9k5xpyRZSvfTM4DnV9WlowtLkiTNxNDd5i2Bm8QlSZqFZvz4VEmSNPuY0CVJ6gETuiRJPWBClySpB0zokiT1gAldkqQeMKFLktQDJnRJknrA+7ELgIPfd864Q5AkrQNb6JIk9YAJXZKkHjChS5LUAyZ0SZJ6wIQuSVIPmNAlSeoBE7okST1gQpckqQdM6JIk9YAJXZKkHjChS5LUAyZ0SZJ6wIQuSVIPmNAlSeoBH586Qj6SVJK0oYyshZ5k9yTfSHJpkkuSvLaVb5/ka0muaH+3a+VJclySZUl+kGS/UcUmSVLfjLLLfRXwZ1W1N7AIeFWSvYGjgbOqai/grDYOcCCwV3sdBXxghLFJktQrI0voVXVdVV3Qhm8DLgN2BRYDJ7fZTgae14YXA6dU51xg2yQ7jyo+SZL6ZINcFJdkAbAvcB6wU1Vd1yZdD+zUhncFlg8sdk0rm7yuo5IsTbJ0xYoVowtakqQ5ZOQJPcmWwKeB11XVrYPTqqqAmsn6quqEqlpYVQvnz5+/HiOVJGnuGmlCT/JQumR+alV9phXfMNGV3v7e2MqvBXYfWHy3ViZJktZglFe5BzgRuKyq3jMwaQlweBs+HPj8QPnL2tXui4BbBrrmJUnSaozyd+hPBl4KXJTkwlb2l8DbgU8lORK4GnhBm3YmcBCwDLgTePkIY5MkqVdGltCr6hwg00x+1hTzF/CqUcUjSVKfeetXSZJ6wIQuSVIPmNAlSeoBE7okST1gQpckqQdM6JIk9YAJXZKkHjChS5LUAyZ0SZJ6wIQuSVIPmNAlSeoBE7okST1gQpckqQdM6JIk9YAJXZKkHjChS5LUAyZ0SZJ6wIQuSVIPmNAlSeoBE7okST1gQpckqQdM6JIk9YAJXZKkHjChS5LUAyZ0SZJ6wIQuSVIPmNAlSeoBE7okST0wb9wBDEpyAHAssAnwL1X19tXNv+zG2zn4fedskNgkSZrNZk0LPckmwPuBA4G9gRcl2Xu8UUmSNDfMmoQOPBFYVlVXVtXPgU8Ci8cckyRJc8JsSui7AssHxq9pZZIkaQ1m1Tn0YSQ5Cjiqjd7+xdc89YfjjGc92hH46biDWM826jrlNSOOZP3ZqI/THNLHOkE/6zXKOu0x3YTZlNCvBXYfGN+tlT1AVZ0AnLChgtpQkiytqoXjjmN9sk5zg3WaG/pYJ+hnvcZVp9nU5f4fwF5J9kyyKXAYsGTMMUmSNCfMmhZ6Va1K8ifAV+h+tvbhqrpkzGFJkjQnzJqEDlBVZwJnjjuOMendaQSs01xhneaGPtYJ+lmvsdQpVTWO7UqSpPVoNp1DlyRJa8mEvoEl2T3JN5JcmuSSJK9t5cckuTbJhe110LhjnakkVyW5qMW/tJVtn+RrSa5of7cbd5zDSvKYgeNxYZJbk7xurh2rJB9OcmOSiwfKpjwu6RyXZFmSHyTZb3yRT2+aOr0zyeUt7s8m2baVL0hy18Dx+uDYAl+Naeo07XstyZvacfphkmePJ+rVm6ZOpw3U56okF7byuXKcpvsOH/9nqqp8bcAXsDOwXxveCvgR3a1ujwH+fNzxrWPdrgJ2nFT2j8DRbfho4B3jjnMt67YJcD3db0Dn1LECngbsB1y8puMCHAR8CQiwCDhv3PHPoE6/Dcxrw+8YqNOCwflm62uaOk35XmvfGd8HHgbsCfwnsMm46zBMnSZNfzfwljl2nKb7Dh/7Z8oW+gZWVddV1QVt+DbgMvp9R7zFwMlt+GTgeeMLZZ08C/jPqrp63IHMVFV9C/jvScXTHZfFwCnVORfYNsnOGyTQGZiqTlX11apa1UbPpbuXxZwxzXGazmLgk1X1s6r6MbCM7vbZs8rq6pQkwAuAT2zQoNbRar7Dx/6ZMqGPUZIFwL7Aea3oT1qXzIfnUtf0gAK+muT8dkc/gJ2q6ro2fD2w03hCW2eH8cAvnrl+rKY7Ln25BfMr6FpFE/ZM8r0k30zy1HEFtZameq/14Tg9Fbihqq4YKJtTx2nSd/jYP1Mm9DFJsiXwaeB1VXUr8AHgV4B9gOvouqLmmqdU1X50T8x7VZKnDU6srv9pzv2sIt2Njp4LnN6K+nCsfmGuHpfpJHkzsAo4tRVdB/xyVe0LvB74eJKtxxXfDPXqvTbJi3jgP8lz6jhN8R3+C+P6TJnQxyDJQ+neCKdW1WcAquqGqrq3qu4DPsQs7D5bk6q6tv29EfgsXR1umOhean9vHF+Ea+1A4IKqugH6cayY/rgMdQvm2SrJEcBzgBe3L1Vat/RNbfh8uvPNjx5bkDOwmvfaXD9O84DnA6dNlM2l4zTVdziz4DNlQt/A2nmjE4HLquo9A+WD51R+F7h48rKzWZItkmw1MUx3gdLFdLfvPbzNdjjw+fFEuE4e0JKY68eqme64LAFe1q7MXQTcMtCNOKslOQB4A/DcqrpzoHx+kk3a8COBvYArxxPlzKzmvbYEOCzJw5LsSVenf9/Q8a2D/YHLq+qaiYK5cpym+w5nNnymxn3F4Mb2Ap5C1xXzA+DC9joI+ChwUStfAuw87lhnWK9H0l11+33gEuDNrXwH4CzgCuBfge3HHesM67UFcBOwzUDZnDpWdP+MXAfcQ3f+7sjpjgvdlbjvp2sdXQQsHHf8M6jTMrpzlROfqw+2eX+vvScvBC4ADh53/DOo07TvNeDN7Tj9EDhw3PEPW6dWfhLwyknzzpXjNN13+Ng/U94pTpKkHrDLXZKkHjChS5LUAyZ0SZJ6wIQuSVIPmNAlSeoBE7okST1gQpdmiSRnTjzyczXz3D5N+UlJDpnBto5L8paB8Tcnef80874uycva8NlJFk4xz3OTHD3s9lcT178k2Xtd1zPDbT7osb+t/F1JnrkhY5HWhb9Dl8as3Xkq1d3ec03z3l5VW05RfhLwxao6Y8htbk13Q4z9W9FZwL5VtXLSfPPobvKxX1WtSnI23eM8l9ITSa6iu9nHTyeV7wF8qKp+eyyBSTNkC11aD5K8PcmrBsaPSfLnSbZMclaSC1orcHGbviDJD5OcQnc7z91bS3HHNv1z7al1lww8uW5i3e9t5WclmT9FLE9oT6s6P8lXMsWjGqt7mMSbgePb6y2Tk3nzTLr72K8aKHtpa81enOSJbZtHJDm+DZ/UegC+k+TKqXoO2q2C/1+S77f1vLCVn51kYWvxX9heP0zy42Hrtr5U96jcHZL80qi2Ia1PJnRp/TiN7tnOE17Qyu4Gfre6p9A9A3h3a5FDd6/q/1tVj6sHP2f9FVX1BGAh8JokO7TyLYClVfU44JvAWwcXag+NeB9wSFv+w8Dbpgq4qj4BbAdsXVUfnaZeTwbOn1S2eVXtA/xxW/9Udqa7ReZzgLdPMf0A4CdV9etV9Xjgy5NiW1JV+7TtfB9417B1S/LigX8GBl/T9V5M9djfCRe0fSDNevPGHYDUB1X1vSSPSLILMB+4uaqWtyT09+keJXsf3XOQJ56TfHVVnTvNKl+T5Hfb8O50yf+mto6JJ1R9DPjMpOUeAzwe+Fr7v2ETuntpP0iS3egS731Jtqyqqc7P7wxcNqnsE63O30qy9TTn/T/XTiFcmmSnKaZfRPfPzTvoThV8e5oY3wDcVVXvT/L4YepWVady/6NTh/GUqro2ySPaui+vqm+1aTcCu8xgXdLYmNCl9ed04BDgl7g/6b6YLsE/oaruaedrN2vT7phqJUmeTndu+0lVdWc7b73ZVPPy4GcuB7ikqp40RLzH0rXwf7X9/Ysp5rlrim1P3uZUF+L8bFJMD1yg6kdJ9qN7qMXfJTmrqv5mcJ4k+wOHAk8bWM8a65bkxUxdl2VV9aDu/xp47G+Sicf+TiT0zej2gTTr2eUurT+nAYfRJfXTW9k2wI0tmT8D2GOI9WxD18K/M8ljgUUD0x7S1g/w+8A5k5b9ITA/yZOg64JP8rjJG0hyIPAI4BTgb4HnT3N1+WXAoyaVTZzvfgrdoyBvGaJOk7e/C3BnVX0MeCew36Tpe9A9oerQqppIqEPVrapOneiun/Sa7lz+VI/9nfBo5ubjcbURsoUurSdVdUlLDtfW/c87PhX4QpKLgKXA5UOs6svAK5NcRpfEBrvl7wCemOSv6LqDXzgphp+3i9COS7IN3Wf8n+geSwlAks1a2SHV/czljiR/QXdx3OSfaX2J7hGeg+5O8j3gocArhqjPVP4H8M4k99E9WvOPJk0/gu5xlJ9r3es/qaqD1lS3tbAT8Nm2jXnAx6vqy/CL6xEeRXfcpFnPn61JWq3WDf2Gqrpi3LFsSO0ahv2q6q/HHYs0DLvcJa3J0XQXx21s5gHvHncQ0rBsoUuS1AO20CVJ6gETuiRJPWBClySpB0zokiT1gAldkqQe+P/2iyMYRAjeEwAAAABJRU5ErkJggg==\n",
      "text/plain": [
       "<Figure size 576x216 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "val_data_for_plot = [len(i) for i in x_val]\n",
    "# fixed bin size\n",
    "bins = np.arange(0, 100, 20) # fixed bin size\n",
    "plt.xlim([min(val_data_for_plot)-5, max(val_data_for_plot)/4+5])\n",
    "plt.hist(val_data_for_plot, bins=bins, alpha=0.8)\n",
    "plt.title('Train reviews lenght histogram')\n",
    "plt.xlabel('variable X (bin size = 5)')\n",
    "plt.ylabel('count')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6d811c39",
   "metadata": {},
   "source": [
    "To decrease RNN training time the maximum review length will be cut to 100 words. For reviews shorter than 100, we'll pad with 0s. For reviews longer than 100, we can truncate them to the first 100 words."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eb3041bb",
   "metadata": {},
   "source": [
    "### Encoding the words with provided vocabulary"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 452,
   "id": "45d5c318",
   "metadata": {},
   "outputs": [],
   "source": [
    "def read_vocab():\n",
    "    '''file format: \"idx : word\" '''\n",
    "    filename = 'imdb.vocab'\n",
    "    # path = os.getcwd() \n",
    "    word2id, id2word = {}, {}\n",
    "\n",
    "    #with open(os.path.join(path, filename), 'r', encoding=\"utf8\") as file:\n",
    "    with open(filename, 'r', encoding=\"utf8\") as file:\n",
    "        for line in file:\n",
    "            word = line.strip()\n",
    "            idx = len(word2id)\n",
    "            if word not in word2id:\n",
    "                word2id[word] = idx\n",
    "                id2word[idx] = word\n",
    "    return word2id, id2word \n",
    "\n",
    "word2id, id2word  = read_vocab()\n",
    "\n",
    "\n",
    "def encode_review(text, word2id):\n",
    "    '''Converts text to numbers. Each word in the text is looked up in the dictionary\n",
    "    and replaced by the corresponding number. If the word is not found - it is replaced with special vector.\n",
    "    '''\n",
    "    # '0' will enlist not only \"the\" token but also all not found words\n",
    "    # we assume that our network will learn it\n",
    "    return [word2id[word] if word in word2id else 0 for word in text]\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 453,
   "id": "fe935883",
   "metadata": {},
   "outputs": [],
   "source": [
    "train_reviews_ints = []\n",
    "test_reviews_ints = []\n",
    "val_reviews_ints = []\n",
    "\n",
    "for each_review in x_train:\n",
    "    train_reviews_ints.append(encode_review(each_review, word2id))\n",
    "for each_review in x_test:\n",
    "    test_reviews_ints.append(encode_review(each_review, word2id))\n",
    "for each_review in x_val:\n",
    "    val_reviews_ints.append(encode_review(each_review, word2id))    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 454,
   "id": "028adbd7",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(30000, 3750)"
      ]
     },
     "execution_count": 454,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(train_reviews_ints), len(test_reviews_ints)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "efa044be",
   "metadata": {},
   "source": [
    "### Padding short reviewes and cutting the lenght of the reviews"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 455,
   "id": "c1e34397",
   "metadata": {},
   "outputs": [],
   "source": [
    "seq_len = 100\n",
    "\n",
    "#padding with zeroes\n",
    "prepared_train_review = np.zeros((len(train_reviews_ints), seq_len), dtype=int)\n",
    "prepared_test_review = np.zeros((len(test_reviews_ints), seq_len), dtype=int)\n",
    "prepared_val_review = np.zeros((len(val_reviews_ints), seq_len), dtype=int)\n",
    "\n",
    "#cutting the lenght\n",
    "for review_number, int_review in enumerate(train_reviews_ints):\n",
    "    prepared_train_review[review_number, -len(int_review):] = np.array(int_review)[:seq_len]\n",
    "\n",
    "for review_number, int_review in enumerate(test_reviews_ints):\n",
    "    prepared_test_review[review_number, -len(int_review):] = np.array(int_review)[:seq_len]\n",
    "    \n",
    "for review_number, int_review in enumerate(val_reviews_ints):\n",
    "    prepared_val_review[review_number, -len(int_review):] = np.array(int_review)[:seq_len]    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 456,
   "id": "d5d0de6d",
   "metadata": {},
   "outputs": [],
   "source": [
    "#prepared_val_review[:10,:100]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "01f34463",
   "metadata": {},
   "source": [
    "### Embeddings"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "633d8da4",
   "metadata": {},
   "source": [
    "###### Develop word2vec embeddings\n",
    "\n",
    "https://machinelearningmastery.com/develop-word-embeddings-python-gensim/"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 457,
   "id": "9f2fc982",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['fasttext-wiki-news-subwords-300', 'conceptnet-numberbatch-17-06-300', 'word2vec-ruscorpora-300', 'word2vec-google-news-300', 'glove-wiki-gigaword-50', 'glove-wiki-gigaword-100', 'glove-wiki-gigaword-200', 'glove-wiki-gigaword-300', 'glove-twitter-25', 'glove-twitter-50', 'glove-twitter-100', 'glove-twitter-200', '__testing_word2vec-matrix-synopsis']\n"
     ]
    }
   ],
   "source": [
    "# Show all available models in gensim-data\n",
    "print(list(gensim.downloader.info()['models'].keys()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 458,
   "id": "a1bf569d",
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Embedding(1193514, 100)"
      ]
     },
     "execution_count": 458,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "n_vocab = len(word2id)\n",
    "n_embed = 100\n",
    "\n",
    "glove_path = gensim.downloader.load('glove-twitter-100', return_path=True)\n",
    "try:\n",
    "    glove_model = gensim.models.keyedvectors.load_word2vec_format(glove_path)\n",
    "except:\n",
    "    glove_model = gensim.models.keyedvectors.load_word2vec_format(glove_path, binary=True)\n",
    "# glove_model = api.load('word2vec-ruscorpora-300')  If we want to load without saving localy \n",
    "\n",
    "#loading the weights into torch Embeddings\n",
    "weights = torch.FloatTensor(glove_model.vectors)\n",
    "# Build nn.Embedding() layer\n",
    "embedding = nn.Embedding.from_pretrained(weights) \n",
    "\n",
    "encoder = nn.Embedding(n_vocab, n_embed)\n",
    "#encoder(torch.from_numpy(prepared_train_review[0]))\n",
    "\n",
    "embedding.requires_grad_(False)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c6139fae",
   "metadata": {},
   "source": [
    "## Data Loders and batching"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 459,
   "id": "95d7d40d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# create Tensor datasets\n",
    "train_data = TensorDataset(torch.from_numpy(prepared_train_review), torch.from_numpy(y_train.to_numpy()))\n",
    "valid_data = TensorDataset(torch.from_numpy(prepared_val_review), torch.from_numpy(y_val.to_numpy()))\n",
    "test_data = TensorDataset(torch.from_numpy(prepared_test_review), torch.from_numpy(y_test.to_numpy()))\n",
    "\n",
    "# dataloaders\n",
    "batch_size = 50\n",
    "\n",
    "train_loader = DataLoader(train_data, shuffle=True, batch_size=batch_size)\n",
    "valid_loader = DataLoader(valid_data, shuffle=True, batch_size=batch_size)\n",
    "test_loader = DataLoader(test_data, shuffle=True, batch_size=batch_size)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 460,
   "id": "6d8669ad",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "GPU not available, CPU used\n"
     ]
    }
   ],
   "source": [
    "is_cuda = torch.cuda.is_available()\n",
    "\n",
    "# If we have a GPU available, we'll set our device to GPU. We'll use this device variable later in our code.\n",
    "if is_cuda:\n",
    "    device = torch.device(\"cuda\")\n",
    "    print(\"GPU is available\")\n",
    "else:\n",
    "    device = torch.device(\"cpu\")\n",
    "    print(\"GPU not available, CPU used\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7287837f",
   "metadata": {},
   "source": [
    "## Training"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 461,
   "id": "00dc2484",
   "metadata": {},
   "outputs": [],
   "source": [
    "# DEFINE THE LSTM MODEL\n",
    "class CustomLSTM(nn.Module):\n",
    "    #def __init__(self, input_sz, hidden_sz):\n",
    "    def __init__(self, n_vocab, n_embed, n_hidden, n_output, n_layers, encoder, drop_p = 0.5):\n",
    "        super().__init__()\n",
    "        self.n_embed = n_embed        \n",
    "        self.n_vocab = n_vocab     # number of unique words in vocabulary\n",
    "        self.n_layers = n_layers   # number of LSTM layers \n",
    "        self.n_hidden = n_hidden   # number of hidden nodes in LSTM\n",
    "        \n",
    "        self.embedding = encoder\n",
    "        \n",
    "        self.dropout = nn.Dropout(drop_p)\n",
    "        self.fc = nn.Linear(n_hidden, n_output)\n",
    "        self.sigmoid = nn.Sigmoid()\n",
    "        \n",
    "        self.W = nn.Parameter(torch.Tensor(n_embed, n_hidden * 4))\n",
    "        self.U = nn.Parameter(torch.Tensor(n_hidden, n_hidden * 4))\n",
    "        self.bias = nn.Parameter(torch.Tensor(n_hidden * 4))\n",
    "        self.init_weights()\n",
    "                \n",
    "    def init_weights(self):\n",
    "        stdv = 1.0 / math.sqrt(self.n_hidden)\n",
    "        for weight in self.parameters():\n",
    "            weight.data.uniform_(-stdv, stdv)\n",
    "         \n",
    "    def forward(self, x, \n",
    "                init_states=None):\n",
    "        \n",
    "        x = self.embedding(x)    # (batch_size, seq_length, n_embed)\n",
    "\n",
    "        \"\"\"Assumes x is of shape (batch, sequence, feature)\"\"\"\n",
    "        bs, seq_sz, _ = x.size()\n",
    "        hidden_seq = []\n",
    "        if init_states is None:\n",
    "            h_t, c_t = (torch.zeros(bs, self.n_hidden).to(x.device), \n",
    "                        torch.zeros(bs, self.n_hidden).to(x.device))\n",
    "        else:\n",
    "            h_t, c_t = init_states\n",
    "         \n",
    "        HS = self.n_hidden\n",
    "        for t in range(seq_sz):\n",
    "            x_t = x[:, t, :]\n",
    "            # batch the computations into a single matrix multiplication\n",
    "            gates = x_t @ self.W + h_t @ self.U + self.bias\n",
    "            i_t, f_t, g_t, o_t = (\n",
    "                torch.sigmoid(gates[:, :HS]), # input\n",
    "                torch.sigmoid(gates[:, HS:HS*2]), # forget\n",
    "                torch.tanh(gates[:, HS*2:HS*3]),\n",
    "                torch.sigmoid(gates[:, HS*3:]), # output\n",
    "            )\n",
    "            c_t = f_t * c_t + i_t * g_t\n",
    "            h_t = o_t * torch.tanh(c_t)\n",
    "            hidden_seq.append(h_t.unsqueeze(0))\n",
    "        hidden_seq = torch.cat(hidden_seq, dim=0)\n",
    "        # reshape from shape (sequence, batch, feature) to (batch, sequence, feature)\n",
    "        hidden_seq = hidden_seq.transpose(0, 1).contiguous()\n",
    "        hidden_seq, (h_t, c_t)\n",
    "        lstm_out, h = hidden_seq, (h_t, c_t)      # (batch_size, seq_length, n_hidden)\n",
    "        lstm_out = self.dropout(lstm_out)\n",
    "        lstm_out = lstm_out.contiguous().view(-1, self.n_hidden) # (batch_size*seq_length, n_hidden)\n",
    "        fc_out = self.fc(lstm_out)                      # (batch_size*seq_length, n_output)\n",
    "        sigmoid_out = self.sigmoid(fc_out)              # (batch_size*seq_length, n_output)\n",
    "        sigmoid_out = sigmoid_out.view(batch_size, -1)  # (batch_size, seq_length*n_output)\n",
    "        \n",
    "        # extract only the output of the last output of the last element of the sequence\n",
    "        sigmoid_last = sigmoid_out[:, -1]               # (batch_size, 1)\n",
    "        \n",
    "        return sigmoid_last, h\n",
    "    \n",
    "    def init_hidden (self, batch_size):  # initialize hidden weights (h,c) to 0\n",
    "        \n",
    "        device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n",
    "        weights = next(self.parameters()).data\n",
    "        h = (weights.new(self.n_layers, batch_size, self.n_hidden).zero_().to(device),\n",
    "             weights.new(self.n_layers, batch_size, self.n_hidden).zero_().to(device))\n",
    "        \n",
    "        return h"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 472,
   "id": "3709ae50",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Instansiate the model hyperparameters\n",
    "n_vocab = len(word2id)\n",
    "n_embed = 100\n",
    "n_hidden = 50\n",
    "n_output = 1   # 1 (\"positive\") or 0 (\"negative\")\n",
    "n_layers = 2\n",
    "\n",
    "net = CustomLSTM(n_vocab, n_embed, n_hidden, n_output, n_layers, encoder = encoder)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 473,
   "id": "7ea42e02",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Define Loss & Optimizer\n",
    "criterion = nn.BCELoss()\n",
    "optimizer = optim.Adam(net.parameters(), lr = 0.01)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 474,
   "id": "4b95e386",
   "metadata": {},
   "outputs": [],
   "source": [
    "#TRAIN THE NETWORK!\n",
    "def train_lstm(net, n_epochs):\n",
    "    train_losses = [None]\n",
    "    val_losses = [None]\n",
    "    print_every = 100\n",
    "    step = 0\n",
    "    clip = 5  # for gradient clip to prevent exploding gradient problem in LSTM/RNN\n",
    "    device = 'cuda' if torch.cuda.is_available() else 'cpu'\n",
    "\n",
    "    test_losses = []\n",
    "    test_accuracies = []\n",
    "    \n",
    "\n",
    "    for epoch in range(n_epochs):\n",
    "        train_lst = []\n",
    "        val_lst = []\n",
    "        h = net.init_hidden(batch_size)\n",
    "\n",
    "        for inputs, labels in train_loader:\n",
    "            step += 1\n",
    "            inputs, labels = inputs.to(device), labels.to(device)\n",
    "\n",
    "            # making requires_grad = False for the latest set of h\n",
    "            h = tuple([each.data for each in h])   \n",
    "\n",
    "            net.zero_grad()\n",
    "            output, h = net(inputs)\n",
    "            loss = criterion(output.squeeze(), labels.float().squeeze())\n",
    "            loss.backward()\n",
    "            nn.utils.clip_grad_norm(net.parameters(), clip)\n",
    "            optimizer.step()\n",
    "\n",
    "            if (step % print_every) == 0:            \n",
    "                ######################\n",
    "                ##### VALIDATION #####\n",
    "                ######################\n",
    "                net.eval()\n",
    "                valid_losses = []\n",
    "                v_h = net.init_hidden(batch_size)\n",
    "\n",
    "                for v_inputs, v_labels in valid_loader:\n",
    "                    v_inputs, v_labels = inputs.to(device), labels.to(device)\n",
    "\n",
    "                    v_h = tuple([each.data for each in v_h])\n",
    "\n",
    "                    v_output, v_h = net(v_inputs)\n",
    "                    v_loss = criterion(v_output.squeeze(), v_labels.float().squeeze())\n",
    "                    valid_losses.append(v_loss.item())\n",
    "\n",
    "                print(\"Epoch: {}/{}\".format((epoch+1), n_epochs),\n",
    "                      \"Step: {}\".format(step),\n",
    "                      \"Training Loss: {:.4f}\".format(loss.item()),\n",
    "                      \"Validation Loss: {:.4f}\".format(np.mean(valid_losses)))\n",
    "                \n",
    "                train_lst.append(loss.item())\n",
    "                val_lst.append(valid_losses[-1])\n",
    "                net.train()\n",
    "        \n",
    "        \n",
    "        train_losses.append(np.mean(train_lst))\n",
    "        val_losses.append(np.mean(val_lst))\n",
    "       \n",
    "    \n",
    "    return net, train_losses, val_losses"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "427d9151",
   "metadata": {},
   "source": [
    "# Results "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0e11e57d",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\User\\AppData\\Local\\Temp/ipykernel_85428/953447495.py:30: UserWarning: torch.nn.utils.clip_grad_norm is now deprecated in favor of torch.nn.utils.clip_grad_norm_.\n",
      "  nn.utils.clip_grad_norm(net.parameters(), clip)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch: 1/10 Step: 100 Training Loss: 0.6527 Validation Loss: 0.6644\n",
      "Epoch: 1/10 Step: 200 Training Loss: 0.5574 Validation Loss: 0.5349\n",
      "Epoch: 1/10 Step: 300 Training Loss: 0.4886 Validation Loss: 0.3863\n",
      "Epoch: 1/10 Step: 400 Training Loss: 0.4793 Validation Loss: 0.3837\n",
      "Epoch: 1/10 Step: 500 Training Loss: 0.3519 Validation Loss: 0.3045\n"
     ]
    }
   ],
   "source": [
    "n_epochs = 10\n",
    "net, train_losses, val_losses = train_lstm(net, n_epochs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3c2f083d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# summarize history for loss\n",
    "plt.rcParams[\"figure.figsize\"] = (8,3)\n",
    "plt.xlim([1, n_epochs])\n",
    "plt.plot(train_losses)\n",
    "plt.plot(val_losses)\n",
    "plt.title('Model loss vs Epochs')\n",
    "plt.ylabel('loss')\n",
    "plt.xlabel('epoch')\n",
    "plt.legend(['train', 'val'], loc='upper right')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "94c62793",
   "metadata": {},
   "outputs": [],
   "source": [
    "def test_results(net, fp = False):\n",
    "    # Test the trained model on the test set\n",
    "    net.eval()\n",
    "    test_losses = []\n",
    "    num_correct = 0\n",
    "    test_h = net.init_hidden(batch_size)\n",
    "    test_out = []\n",
    "    test_labels = []\n",
    "\n",
    "    for inputs, labels in test_loader:\n",
    "        test_h = tuple([each.data for each in test_h])\n",
    "        test_output, test_h = net(inputs)\n",
    "        loss = criterion(test_output.squeeze(), labels.float().squeeze())\n",
    "        test_losses.append(loss.item())\n",
    "\n",
    "        preds = torch.round(test_output.squeeze())\n",
    "        correct_tensor = preds.eq(labels.float().view_as(preds))\n",
    "        correct = np.squeeze(correct_tensor.numpy())\n",
    "        num_correct += np.sum(correct)\n",
    "        if fp:\n",
    "            for i in range(50):\n",
    "                test_labels.append(labels.float()[i].item())\n",
    "                test_out.append(1-preds.float()[i].item())\n",
    "        else:\n",
    "            for i in range(50):\n",
    "                test_labels.append(labels.float()[i].item())\n",
    "                test_out.append(preds.float()[i].item())\n",
    "            \n",
    "    print(\"Test Loss: {:.4f}\".format(np.mean(test_losses)))\n",
    "    print(\"Test Accuracy: {:.2f}\".format(num_correct/len(test_loader.dataset)))\n",
    "    return  test_out, test_labels\n",
    "\n",
    "test_out, test_labels = test_results(net)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9a31ab8f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#ROC curve and calculate AUC for the test set\n",
    "plt.rcParams[\"figure.figsize\"] = (8,3)\n",
    "plt.plot([0, 1], [0, 1], linestyle='--', lw=2, color='r', label='Random guess')\n",
    "fpr, tpr, _ = metrics.roc_curve(np.array(test_out), np.array(test_labels))\n",
    "auc = metrics.roc_auc_score(np.array(test_out),  np.array(test_labels))\n",
    "plt.plot(fpr, tpr, label=\"Data ROC, AUC=\"+str(auc))\n",
    "plt.title('ROC and ACU for the test set')\n",
    "plt.ylabel('TPR')\n",
    "plt.xlabel('FPR')\n",
    "plt.legend(loc=4)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8cffe8b6",
   "metadata": {},
   "source": [
    "## second embedding"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4438b31f",
   "metadata": {},
   "outputs": [],
   "source": [
    "n_vocab = len(word2id)\n",
    "\n",
    "glove_path = gensim.downloader.load('word2vec-google-news-300', return_path=True)\n",
    "try:\n",
    "    glove_model = gensim.models.keyedvectors.load_word2vec_format(glove_path)\n",
    "except:\n",
    "    glove_model = gensim.models.keyedvectors.load_word2vec_format(glove_path, binary=True)\n",
    "# glove_model = api.load('word2vec-ruscorpora-300')  If we want to load without saving localy \n",
    "\n",
    "#loading the weights into torch Embeddings\n",
    "weights1 = torch.FloatTensor(glove_model.vectors)\n",
    "# Build nn.Embedding() layer\n",
    "embedding1 = nn.Embedding.from_pretrained(weights1) \n",
    "\n",
    "encoder1 = nn.Embedding(n_vocab, n_embed)\n",
    "#encoder(torch.from_numpy(prepared_train_review[0]))\n",
    "\n",
    "embedding.requires_grad_(False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "feacf9c3",
   "metadata": {},
   "outputs": [],
   "source": [
    "net1 = CustomLSTM(n_vocab, n_embed, n_hidden, n_output, n_layers, encoder = encoder1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a34256f0",
   "metadata": {},
   "outputs": [],
   "source": [
    "net1, train_losses1, val_losses1 = train_lstm(net1, n_epochs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "285c621f",
   "metadata": {},
   "outputs": [],
   "source": [
    "#test_results(net1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fc72a613",
   "metadata": {},
   "outputs": [],
   "source": [
    "# summarize history for loss\n",
    "plt.rcParams[\"figure.figsize\"] = (8,3)\n",
    "plt.plot(train_losses1)\n",
    "plt.plot(val_losses1)\n",
    "plt.title('Model loss vs Epochs')\n",
    "plt.ylabel('loss')\n",
    "plt.xlabel('epoch')\n",
    "plt.legend(['train', 'val'], loc='upper right')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e99d939a",
   "metadata": {},
   "outputs": [],
   "source": [
    "test_out1, test_labels1 = test_results(net1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d426deeb",
   "metadata": {},
   "outputs": [],
   "source": [
    "#ROC curve and calculate AUC for the test set\n",
    "plt.rcParams[\"figure.figsize\"] = (8,3)\n",
    "plt.plot([0, 1], [0, 1], linestyle='--', lw=2, color='r', label='Random guess')\n",
    "fpr, tpr, _ = metrics.roc_curve(np.array(test_out1), np.array(test_labels1))\n",
    "auc = metrics.roc_auc_score(np.array(test_out1),  np.array(test_labels1))\n",
    "plt.plot(fpr, tpr, label=\"Data ROC, AUC=\"+str(auc))\n",
    "plt.title('ROC and ACU for the test set')\n",
    "plt.ylabel('TPR')\n",
    "plt.xlabel('FPR')\n",
    "plt.legend(loc=4)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e14d1a10",
   "metadata": {},
   "source": [
    "# Conclusions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e54da6f1",
   "metadata": {},
   "outputs": [],
   "source": [
    "#https://rguigoures.github.io/word2vec_pytorch/"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "19ab94d0",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
